{% extends "base_logged.html" %}
{% load static %}

{% block extra_css %}
<style>
  /* Position delete button in top-right corner */
  .book-entry {
    position: relative;
    padding-right: 3rem; /* Make room for delete button */
  }
  .book-entry .delete {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
  }

  /* Hide deleted entries but keep in DOM for form submission */
  .book-entry.is-deleted {
    display: none;
  }
</style>
{% endblock %}

{% block logged_content %}
<div class="columns is-centered">
  <div class="column is-full-mobile is-10-tablet is-8-desktop">
    <h1 class="title is-4 mb-2">Mis libros ofrecidos</h1>
    <p class="mb-4 has-text-grey">
      Agregá abajo los libros que tenés para cambiar. Usá las observaciones para aclarar lo que quieras (editorial, condición, género, etc).
    </p>

    <form method="post" id="books-form">
      {% csrf_token %}
      {{ formset.management_form }}

      <div id="books-container">
        {% for form in formset %}
        <div class="box book-entry {% if forloop.last %}new-entry{% endif %}" {% if form.instance.pk %}data-book-id="{{ form.instance.pk }}"{% endif %}>
          <button type="button" class="delete delete-btn" aria-label="Eliminar" title="Borrar libro" tabindex="-1"></button>

          {# Hidden fields for formset #}
          {{ form.id }}

          <div class="columns">
            <div class="column">
              <div class="field">
                <input class="input" type="text" name="{{ form.title.html_name }}" id="{{ form.title.id_for_label }}" value="{{ form.title.value|default:'' }}" placeholder="Título del libro">
                {% if form.title.errors %}
                  <p class="help is-danger">{{ form.title.errors.0 }}</p>
                {% endif %}
              </div>
              <div class="field">
                <input class="input" type="text" name="{{ form.author.html_name }}" id="{{ form.author.id_for_label }}" value="{{ form.author.value|default:'' }}" placeholder="Autor">
                {% if form.author.errors %}
                  <p class="help is-danger">{{ form.author.errors.0 }}</p>
                {% endif %}
              </div>
            </div>
            <div class="column">
              {{ form.notes }}
              {% if form.notes.errors %}
                <p class="help is-danger">{{ form.notes.errors.0 }}</p>
              {% endif %}
            </div>
          </div>

          {# Hidden DELETE checkbox (we'll handle this with JavaScript) #}
          <div style="display: none;">
            {{ form.DELETE }}
          </div>
        </div>
        {% endfor %}
      </div>

      <div class="field is-grouped is-grouped-right mt-4">
        <div class="control">
          <button type="button" class="button" id="cancel-btn">
            <span id="cancel-btn-text">Volver</span>
          </button>
        </div>
        <div class="control" id="save-btn-container" style="display: none;">
          <button type="submit" class="button is-primary">
            Guardar cambios
          </button>
        </div>
      </div>
    </form>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('books-container');
  const form = document.getElementById('books-form');
  const cancelBtn = document.getElementById('cancel-btn');
  const cancelBtnText = document.getElementById('cancel-btn-text');
  const saveBtnContainer = document.getElementById('save-btn-container');
  let newEntryCounter = 1;
  let isDirty = false;

  // Track form changes
  function markDirty() {
    if (!isDirty) {
      isDirty = true;
      cancelBtnText.textContent = 'Cancelar';
      saveBtnContainer.style.display = '';
    }
  }

  // Setup change listeners to track form modifications
  function setupChangeListeners(element) {
    const inputs = element.querySelectorAll('input[type="text"], textarea');
    inputs.forEach(input => {
      input.addEventListener('input', () => {
        markDirty();
      });
    });
  }

  // Auto-add new entry when typing in the last entry
  function setupAutoAddEntry() {
    const lastEntry = container.querySelector('.new-entry:last-of-type');
    if (!lastEntry) return;

    const inputs = lastEntry.querySelectorAll('input[type="text"], textarea');
    inputs.forEach(input => {
      input.addEventListener('input', (e) => {
        // Check if any field in the last entry has content
        const hasContent = Array.from(inputs).some(inp => inp.value.trim() !== '');

        if (hasContent) {
          // Check if there's already another empty entry
          const emptyEntries = container.querySelectorAll('.new-entry');
          const hasEmptyEntry = Array.from(emptyEntries).some(entry => {
            const entryInputs = entry.querySelectorAll('input[type="text"], textarea');
            return Array.from(entryInputs).every(inp => inp.value.trim() === '');
          });

          if (!hasEmptyEntry) {
            addNewEntry();
          }
        }
      });
    });
  }

  // Add a new empty entry
  function addNewEntry() {
    // Get current total forms count
    const totalFormsInput = document.querySelector('[name$="TOTAL_FORMS"]');
    const currentTotal = parseInt(totalFormsInput.value);
    const newIndex = currentTotal;

    // Update total forms
    totalFormsInput.value = currentTotal + 1;

    const newEntry = document.createElement('div');
    newEntry.className = 'box book-entry new-entry';
    newEntry.innerHTML = `
      <button type="button" class="delete delete-btn" aria-label="Eliminar" title="Borrar libro" tabindex="-1"></button>
      <div class="columns">
        <div class="column">
          <div class="field">
            <input class="input" type="text" name="form-${newIndex}-title" id="id_form-${newIndex}-title" placeholder="Título del libro">
          </div>
          <div class="field">
            <input class="input" type="text" name="form-${newIndex}-author" id="id_form-${newIndex}-author" placeholder="Autor">
          </div>
        </div>
        <div class="column">
          <textarea class="textarea" name="form-${newIndex}-notes" id="id_form-${newIndex}-notes" rows="4" placeholder="Observaciones (opcional)"></textarea>
        </div>
      </div>
      <input type="hidden" name="form-${newIndex}-id" id="id_form-${newIndex}-id">
      <div style="display: none;">
        <input type="checkbox" name="form-${newIndex}-DELETE" id="id_form-${newIndex}-DELETE">
      </div>
    `;
    container.appendChild(newEntry);
    setupAutoAddEntry();
    setupDeleteButtons();
    setupChangeListeners(newEntry);
  }

  // Handle delete buttons
  function setupDeleteButtons() {
    const deleteButtons = container.querySelectorAll('.delete-btn');
    deleteButtons.forEach(btn => {
      // Remove old listeners by cloning
      const newBtn = btn.cloneNode(true);
      btn.parentNode.replaceChild(newBtn, btn);

      newBtn.addEventListener('click', (e) => {
        const entry = e.currentTarget.closest('.book-entry');

        // If it's an existing book (has data-book-id), mark for deletion
        if (entry.dataset.bookId) {
          entry.classList.add('is-deleted');

          // Check the Django formset DELETE checkbox
          const deleteCheckbox = entry.querySelector('input[name$="-DELETE"]');
          if (deleteCheckbox) {
            deleteCheckbox.checked = true;
          }

          markDirty();
        } else {
          // If it's a new entry, just remove it (but keep at least one empty entry)
          const newEntries = container.querySelectorAll('.new-entry:not(.is-deleted)');
          if (newEntries.length > 1) {
            entry.remove();
            markDirty();
          } else {
            // Clear the fields instead of removing
            const fields = entry.querySelectorAll('input[type="text"], textarea');
            fields.forEach(field => field.value = '');
          }
        }
      });
    });
  }

  // Cancel button
  cancelBtn.addEventListener('click', () => {
    if (isDirty) {
      if (confirm('¿Descartar los cambios?')) {
        window.location.reload();
      }
    } else {
      // TODO: Navigate to profile view once implemented
      window.location.href = '/';
    }
  });

  // Form submission - Django will handle validation and ignore empty forms

  // Ensure there's always at least one empty entry
  function ensureEmptyEntry() {
    const emptyEntries = container.querySelectorAll('.new-entry');
    const hasEmptyEntry = Array.from(emptyEntries).some(entry => {
      const entryInputs = entry.querySelectorAll('input[type="text"], textarea');
      return Array.from(entryInputs).every(inp => inp.value.trim() === '');
    });

    if (!hasEmptyEntry) {
      addNewEntry();
    }
  }

  // Initialize
  setupAutoAddEntry();
  setupDeleteButtons();
  ensureEmptyEntry();

  // Setup change listeners for all existing entries
  container.querySelectorAll('.book-entry').forEach(entry => {
    setupChangeListeners(entry);
  });
});
</script>
{% endblock %}
